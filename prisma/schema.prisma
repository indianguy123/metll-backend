generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             Int      @id @default(autoincrement())
  phoneNumber    String   @unique
  email          String?
  password       String
  name           String?
  
  // Core status flags
  isVerified           Boolean  @default(false)
  isOnboarded          Boolean  @default(false)  // Phase 1 complete
  isDiscoverOnboarded  Boolean  @default(false)  // Phase 2 complete
  
  // OTP fields
  otp           String?
  otpExpiresAt  DateTime?
  otpAttempts   Int       @default(0)
  lastOtpSentAt DateTime?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Referral System
  referralCode String @unique @default(cuid())
  referredById Int?
  referredBy   User?  @relation("Referrals", fields: [referredById], references: [id])
  referrals    User[] @relation("Referrals")

  totalReferrals Int @default(0)
  rewardsEarned  Int @default(0)
  rewardsUsed    Int @default(0)
  referralStatus String @default("active")

  profilePhoto       String?
  profilePhotoPublicId String?
  images             String[] @default([])
  verificationStatus String   @default("pending") // pending, photo_uploaded, verified, failed
  verificationScore  Float?
  verificationDate   DateTime?
  livenessSessionId  String?
  faceId             String?

  // Relations to new normalized tables
  profile              UserProfile?
  datingPrefs          DatingPreferences?
  photos               UserPhoto[]
  verification         UserVerification?
  personalityResponses PersonalityResponse[]
  school               UserSchool?
  college              UserCollege?
  office               UserOffice?
  
  // Existing relations
  rewards         Reward[]   @relation("UserRewards")
  referralRecords Referral[] @relation("ReferrerRecords")
  referredRecords Referral[] @relation("ReferredUserRecords")

  confessions    Confession[]
  matchesAsUser1 Match[]      @relation("User1Matches")
  matchesAsUser2 Match[]      @relation("User2Matches")

  swipesMade     Swipe[] @relation("SwipesMade")
  swipesReceived Swipe[] @relation("SwipesReceived")

  messages Message[]

  reportsMade     Report[] @relation("ReportsMade")
  reportsReceived Report[] @relation("ReportsReceived")

  @@index([isVerified])
  @@index([isOnboarded])
  @@index([isDiscoverOnboarded])
}

// ==========================================
// Profile & Background Tables
// ==========================================

model UserProfile {
  id        Int    @id @default(autoincrement())
  userId    Int    @unique
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  bio       String?
  age       Int?
  gender    String?  // male, female, non-binary, other
  height    Int?     // in cm
  
  // Location
  latitude    Float?
  longitude   Float?
  currentCity String?
  pastCity    String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([gender])
  @@index([currentCity])
}

model UserSchool {
  id        Int    @id @default(autoincrement())
  userId    Int    @unique
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  name      String
  city      String?
  state     String?
  class     String?
  section   String?
}

model UserCollege {
  id         Int    @id @default(autoincrement())
  userId     Int    @unique
  user       User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  name       String
  department String?
  location   String?
}

model UserOffice {
  id          Int    @id @default(autoincrement())
  userId      Int    @unique
  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  name        String
  designation String?
  department  String?
  location    String?
}

// ==========================================
// Photos Table
// ==========================================

model UserPhoto {
  id        Int     @id @default(autoincrement())
  userId    Int
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  url       String
  publicId  String  // Cloudinary public ID
  type      String  // 'profile', 'additional'
  order     Int     @default(0)
  
  createdAt DateTime @default(now())
  
  @@index([userId, type])
  @@index([userId, order])
}

// ==========================================
// Verification Table
// ==========================================

model UserVerification {
  id              Int      @id @default(autoincrement())
  userId          Int      @unique
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  videoUrl        String?
  videoPublicId   String?
  faceId          String?  // AWS Rekognition
  status          String   @default("pending") // pending, photo_uploaded, verified, failed
  score           Float?   // 0-100 similarity
  verifiedAt      DateTime?
  livenessSession String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([status])
}

// ==========================================
// Dating Preferences Table
// ==========================================

model DatingPreferences {
  id     Int  @id @default(autoincrement())
  userId Int  @unique
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Relationship Type
  relationshipType String @default("open_to_all") 
  // Options: friends_first, monogamy, non_monogamy, open_to_all, figuring_out
  
  // Dating Intention
  datingIntention String @default("open_to_all")
  // Options: casual, serious, marriage, open_to_all
  
  // Preferences (who to show)
  genderPreference   String[] @default(["all"]) // male, female, non-binary, all
  ageMin             Int      @default(18)
  ageMax             Int      @default(50)
  distanceMax        Int      @default(50) // km
  
  // Lifestyle
  children      String? // have, want, dont_want, open
  familyPlans   String? // want, dont_want, open
  smoking       String? // never, sometimes, regularly, prefer_not_say
  drinking      String? // never, socially, regularly, prefer_not_say
  drugs         String? // never, sometimes, prefer_not_say
  politics      String? // liberal, moderate, conservative, prefer_not_say
  education     String? // high_school, bachelors, masters, doctorate, prefer_not_say
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ==========================================
// Personality Responses Table
// ==========================================

model PersonalityResponse {
  id         Int      @id @default(autoincrement())
  userId     Int
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  questionId Int
  answer     String
  answeredAt DateTime @default(now())
  
  @@unique([userId, questionId])
  @@index([userId])
}

model Report {
  id          Int      @id @default(autoincrement())
  reporterId  Int
  reportedId  Int
  category    String   // Inappropriate Content, Spam, Abusive Behavior, Catfishing, Other
  reason      String   // Compulsory comment
  status      String   @default("pending") // pending, reviewed, resolved
  createdAt   DateTime @default(now())

  reporter    User     @relation("ReportsMade", fields: [reporterId], references: [id])
  reported    User     @relation("ReportsReceived", fields: [reportedId], references: [id])

  @@index([reporterId])
  @@index([reportedId])
}

model Confession {
  id           Int      @id @default(autoincrement())
  userId       Int
  targetUserId Int?
  description  String
  latitude     Float?
  longitude    Float?
  isMatched    Boolean  @default(false)
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Match {
  id        Int      @id @default(autoincrement())
  user1Id   Int
  user2Id   Int
  matchedAt DateTime @default(now())

  // Sponsored Coffee Date Ticket
  coffeeTicket       Boolean   @default(false) // True if this match won a sponsored coffee date
  coffeeTicketCafe   String?   // Name/location of the cafe for the date
  coffeeTicketExpiry DateTime? // When the ticket expires

  user1    User      @relation("User1Matches", fields: [user1Id], references: [id], onDelete: Cascade)
  user2    User      @relation("User2Matches", fields: [user2Id], references: [id], onDelete: Cascade)
  chatRoom ChatRoom?

  @@unique([user1Id, user2Id])
}

// Track swipe actions (likes/passes)
model Swipe {
  id        Int      @id @default(autoincrement())
  swiperId  Int // User who swiped
  swipedId  Int // User being swiped on
  direction String // 'like' or 'pass'
  createdAt DateTime @default(now())

  swiper User @relation("SwipesMade", fields: [swiperId], references: [id], onDelete: Cascade)
  swiped User @relation("SwipesReceived", fields: [swipedId], references: [id], onDelete: Cascade)

  @@unique([swiperId, swipedId])
  @@index([swipedId, direction])
}

// Chat room created when two users match
model ChatRoom {
  id        Int      @id @default(autoincrement())
  matchId   Int      @unique
  createdAt DateTime @default(now())

  match       Match            @relation(fields: [matchId], references: [id], onDelete: Cascade)
  messages    Message[]
  calls       Call[]
  hostSession ChatHostSession?
}

// Individual chat messages
model Message {
  id         Int      @id @default(autoincrement())
  chatRoomId Int
  senderId   Int
  content    String? // Make content optional as it might be just an image
  type       String   @default("text") // text, image, video, audio, voice_note, gif
  mediaUrl   String?
  
  // Voice Note fields
  duration     Int?    // Duration in seconds for voice notes
  transcript   String? // Optional transcription for voice notes
  waveformData String? // JSON string of waveform amplitudes
  
  // GIF fields
  gifId        String? // Giphy GIF ID
  gifWidth     Int?    // GIF width
  gifHeight    Int?    // GIF height
  
  createdAt  DateTime @default(now())
  isRead     Boolean  @default(false)

  chatRoom ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  sender   User     @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([chatRoomId, createdAt])
}

// Voice/Video calls between matched users
model Call {
  id          Int       @id @default(autoincrement())
  chatRoomId  Int
  callerId    Int // User who initiated the call
  receiverId  Int // User receiving the call
  channelName String    @unique // Agora channel name
  status      String    @default("pending") // pending, active, ended, missed
  type        String    @default("voice") // voice or video
  startedAt   DateTime?
  endedAt     DateTime?
  duration    Int? // Call duration in seconds
  createdAt   DateTime  @default(now())

  chatRoom ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)

  @@index([chatRoomId, createdAt])
  @@index([callerId])
  @@index([receiverId])
}

// AI Host Session for facilitating conversations between matched users
model ChatHostSession {
  id           Int       @id @default(autoincrement())
  chatRoomId   Int       @unique
  matchId      Int
  status       String    @default("pending") // pending, active, completed, declined, exited
  currentStage String? // STAGE_0, STAGE_1, STAGE_2, STAGE_3, STAGE_4, STAGE_5, STAGE_6
  user1OptIn   Boolean   @default(false)
  user2OptIn   Boolean   @default(false)
  stageData    Json? // Store stage-specific data (answers, game results, etc.)
  startedAt    DateTime?
  completedAt  DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  chatRoom ChatRoom          @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  messages ChatHostMessage[]

  @@index([matchId])
  @@index([status])
}

// AI Host messages and user responses
model ChatHostMessage {
  id          Int      @id @default(autoincrement())
  sessionId   Int
  senderType  String // 'host', 'user1', 'user2'
  senderId    Int? // User ID if senderType is user
  content     String
  messageType String   @default("text") // text, question, button, game_prompt
  metadata    Json? // Store question options, button data, game type, etc.
  createdAt   DateTime @default(now())

  session ChatHostSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId, createdAt])
}

// Referral System Models
model Referral {
  id             Int       @id @default(autoincrement())
  referrerId     Int // User who shared the code
  referredUserId Int // User who used the code
  status         String    @default("pending") // "pending", "completed", "invalid"
  completedAt    DateTime?
  createdAt      DateTime  @default(now())

  referrer     User @relation("ReferrerRecords", fields: [referrerId], references: [id])
  referredUser User @relation("ReferredUserRecords", fields: [referredUserId], references: [id])

  @@unique([referrerId, referredUserId])
  @@index([referrerId])
  @@index([status])
}

model Reward {
  id        Int       @id @default(autoincrement())
  userId    Int
  type      String // "coffee_date"
  status    String    @default("available") // "available", "used", "expired"
  earnedAt  DateTime  @default(now())
  usedAt    DateTime?
  expiresAt DateTime? // Optional expiration

  user User @relation("UserRewards", fields: [userId], references: [id])

  @@index([userId, status])
}
